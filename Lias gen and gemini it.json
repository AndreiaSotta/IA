{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-chat-webhook",
        "responseMode": "responseNode",
        "options": {
          "rawBody": false,
          "allowedOrigins": "{{ $env.ALLOWED_ORIGINS }}"
        }
      },
      "name": "Master Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "executeOn": "main",
      "webhookId": "{{ generateUuid() }}",
      "position": [
        200,
        800
      ]
    },
    {
      "parameters": {
        "functionCode": "// Security Validator: Sanitizes input and performs basic security checks.\n// Uses a simpler UUID generation as 'crypto' module might not be available in n8n Code nodes.\n\nconst inputData = $input.first().json;\nconst body = inputData.body || {};\n\nconst sqlInjectionPattern = /(\\'|(\\\\-\\\\-)|(;)|(\\\\||\\\\||)|(\\\\*|\\\\*)|(%7C))/i;\nconst dosPattern = /(.{1000,})/; \n\nif (!body.message || typeof body.message !== 'string') {\n  throw new Error('Validation Error: Invalid or missing message field');\n}\n\n// Basic security checks\nif (sqlInjectionPattern.test(body.message) || dosPattern.test(body.message)) {\n  throw new Error('Security validation failed: Potentially malicious input detected.');\n}\n\n// Sanitize message: Remove HTML tags, limit length, and escape basic characters.\nconst sanitizedMessage = body.message\n  .trim()\n  .substring(0, 1000) // Limit message length to prevent excessively long prompts\n  .replace(/[<>&\"']/g, (match) => {\n    const escapeMap = {'<': '&lt;', '>': '&gt;', '&': '&amp;', '\"': '&quot;', \"'\": '&#x27;'};\n    return escapeMap[match];\n  });\n\n// Generate a simple UUID if crypto.randomUUID is not available\nfunction generateSimpleUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n// Simple hash for message content (non-cryptographic, for identification/caching)\nfunction simpleHash(data) {\n    if (!data) return null;\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n        const char = data.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return Math.abs(hash).toString(16); // Returns a simple hex string\n}\n\n// Use existing session ID or generate a new one\nconst sessionId = body.sessionId || generateSimpleUUID();\n\n// Generate a hash for the message using the new simpleHash function\nconst messageHash = simpleHash(sanitizedMessage + sessionId); \n\n// Determine language based on input, default to 'pt'\nconst language = ['pt', 'en'].includes(body.language) ? body.language : 'pt';\n\nconst validatedData = {\n  message: sanitizedMessage,\n  language: language,\n  sessionId: sessionId,\n  messageHash: messageHash,\n  timestamp: new Date().toISOString(),\n  userAgent: inputData.headers?.['user-agent'] || 'unknown',\n  ip: inputData.headers?.['x-forwarded-for'] || inputData.headers?.['x-real-ip'] || 'unknown'\n};\n\nreturn [{ json: validatedData }];"
      },
      "name": "Security Validator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        800
      ]
    },
    {
      "parameters": {
        "functionCode": "// Advanced Language Detection: Detects PT-PT or EN using patterns and assigns confidence.\n// All sensitive data is hashed for GDPR compliance using simple string hashing.\n\nconst userMessage = $json.message;\nconst userAgent = $json.userAgent;\nconst clientIP = $json.ip;\nconst sessionId = $json.sessionId;\n\n// GDPR-compliant hashing (simple, non-cryptographic hash for n8n Code Node compatibility)\nfunction hashData(data) {\n  if (!data) return null;\n  let hash = 0;\n  for (let i = 0; i < data.length; i++) {\n      const char = data.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash |= 0; // Convert to 32bit integer\n  }\n  return Math.abs(hash).toString(16); // Returns a simple hex string\n}\n\n// Portuguese language patterns\nconst portuguesePatterns = [\n  /\\b(ol√°|oi|bom\\s+dia|boa\\s+tarde|boa\\s+noite)\\b/i,\n  /\\b(obrigad[oa]|desculp[ae]|por\\s+favor)\\b/i,\n  /\\b(agendar|marcar|reuni√£o|encontro|consulta)\\b/i,\n  /\\b(sim|n√£o|talvez|claro|certamente)\\b/i,\n  /\\b(como\\s+est√°|tudo\\s+bem|que\\s+tal)\\b/i,\n  /\\b(empresa|neg√≥cio|servi√ßo|produto)\\b/i,\n  /[√†√°√¢√£√ß√©√™√≠√≥√¥√µ√∫]/i\n];\n\n// English language patterns\nconst englishPatterns = [\n  /\\b(hello|hi|good\\s+morning|good\\s+afternoon|good\\s+evening)\\b/i,\n  /\\b(thank\\s+you|thanks|sorry|please)\\b/i,\n  /\\b(schedule|book|appointment|meeting|consultation)\\b/i,\n  /\\b(yes|no|maybe|sure|certainly)\\b/i,\n  /\\b(how\\s+are\\s+you|how's\\s+it\\s+going|what's\\s+up)\\b/i,\n  /\\b(company|business|service|product)\\b/i\n];\n\n// Calculate language confidence\nfunction detectLanguage(message) {\n  const ptMatches = portuguesePatterns.reduce((count, pattern) => {\n    return count + (pattern.test(message) ? 1 : 0);\n  }, 0);\n  \n  const enMatches = englishPatterns.reduce((count, pattern) => {\n    return count + (pattern.test(message) ? 1 : 0);\n  }, 0);\n  \n  // Check for Portuguese characters for stronger PT signal\n  const hasPortugueseChars = /[√†√°√¢√£√ß√©√™√≠√≥√¥√µ√∫]/i.test(message);\n  \n  let language = 'en'; // Default to English if no strong signal\n  let confidence = 0.5;\n  \n  if (ptMatches > enMatches || (ptMatches > 0 && hasPortugueseChars)) {\n    language = 'pt';\n    confidence = Math.min(0.95, 0.5 + (ptMatches * 0.1) + (hasPortugueseChars ? 0.2 : 0));\n  } else if (enMatches > ptMatches) {\n    language = 'en';\n    confidence = Math.min(0.95, 0.5 + (enMatches * 0.1));\n  }\n  \n  return { language, confidence };\n}\n\nconst detection = detectLanguage(userMessage);\nconst timestamp = new Date().toISOString();\n\n// Hash sensitive data for GDPR compliance\nconst hashedIP = hashData(clientIP);\nconst hashedUserAgent = hashData(userAgent);\n\n// Pass through original language if provided in session for persistence\nconst sessionLanguage = $json.language || detection.language;\n\nreturn [{\n  json: {\n    originalMessage: userMessage,\n    sanitizedMessage: userMessage, // Renamed to message for consistency after security validator\n    detectedLanguage: detection.language,\n    confidence: detection.confidence,\n    sessionId,\n    timestamp,\n    hashedIP,\n    hashedUserAgent,\n    sessionLanguage: sessionLanguage // Carries through the preferred session language\n  }\n}];"
      },
      "name": "Language Detection",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        600,
        800
      ]
    },
    {
      "parameters": {
        "conditions": [
          {
            "value1": "={{ $json.sanitizedMessage }}",
            "operator": "isNotEmpty"
          }
        ]
      },
      "name": "Cache Check Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        800,
        800
      ]
    },
    {
      "parameters": {
        "functionCode": "// In-Memory Cache Implementation with TTL and size limits (simulated persistent cache).\n// IMPORTANT: For true persistence (e.g., across n8n restarts or multiple workers), use Redis or a database.\n// 'global' variables are session-specific within a single n8n process.\n\nclass SimpleCache {\n  constructor() {\n    // Initialize global cache maps if they don't exist\n    if (!global.chatbotCache) {\n      global.chatbotCache = new Map();\n      global.cacheTimestamps = new Map();\n    }\n  }\n  \n  get(key) {\n    const now = Date.now();\n    const timestamp = global.cacheTimestamps.get(key);\n    \n    // Check if expired (10 minutes = 600,000ms)\n    if (!timestamp || (now - timestamp) > 600000) {\n      this.delete(key);\n      return null;\n    }\n    \n    return global.chatbotCache.get(key);\n  }\n  \n  set(key, value) {\n    // Limit cache size to 1000 entries\n    if (global.chatbotCache.size >= 1000) {\n      // Delete the oldest entry if limit is reached\n      const oldestKey = global.cacheTimestamps.keys().next().value; // Map.keys() iterates in insertion order\n      this.delete(oldestKey);\n    }\n    \n    global.chatbotCache.set(key, value);\n    global.cacheTimestamps.set(key, Date.now());\n  }\n  \n  delete(key) {\n    global.chatbotCache.delete(key);\n    global.cacheTimestamps.delete(key);\n  }\n  \n  clear() {\n    global.chatbotCache.clear();\n    global.cacheTimestamps.clear();\n  }\n}\n\nconst cache = new SimpleCache();\nconst { sanitizedMessage, sessionId, detectedLanguage, messageHash } = $json;\n\n// Create a more robust cache key based on message hash or session ID + message\nconst cacheKey = `${sessionId}:${messageHash}`; \n\n// Check cache\nconst cachedResponse = cache.get(cacheKey);\n\nif (cachedResponse) {\n  return [{\n    json: {\n      ...$json,\n      response: cachedResponse.response,\n      language: cachedResponse.language,\n      fromCache: true,\n      cacheKey,\n      timestamp: new Date().toISOString() // Update timestamp for this step\n    }\n  }];\n} else {\n  // Pass through original data if not cached\n  return [{\n    json: {\n      ...$json,\n      cacheKey,\n      fromCache: false\n    }\n  }];\n}"
      },
      "name": "Cache Checker",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        750
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/company_knowledge?language=eq.{{ $json.detectedLanguage }}&active=eq.true&order=priority.asc&limit=50",
        "options": {
          "timeout": 10000,
          "response": { "neverError": true }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        }
      },
      "name": "Knowledge Base Fetch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1200,
        750
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations?session_id=eq.{{ $json.sessionId }}&order=created_at.desc&limit=5",
        "options": {
          "timeout": 5000,
          "response": { "neverError": true }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        }
      },
      "name": "Conversation History Fetch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1400,
        750
      ]
    },
    {
      "parameters": {
        "functionCode": "// Llama3.2 AI Processor: Builds a bilingual system prompt with company context and conversation history.\n\nconst { \n  sanitizedMessage, \n  detectedLanguage, \n  sessionId, \n  cacheKey \n} = $input.first().json;\n\n// Access knowledge base and conversation history from previous HTTP Request nodes\nconst knowledgeBaseResponse = $input.item(1).json.body || [];\nconst conversationHistoryResponse = $input.item(2).json.body || [];\n\n// Build context from knowledge base (filtering by language)\nfunction buildKnowledgeContext(kb, lang) {\n  if (!Array.isArray(kb) || kb.length === 0) return '';\n  \n  const relevantKB = kb.filter(item => \n    item.language === lang || item.language === 'both' || !item.language // Include if language matches or is generic/both\n  ).slice(0, 10); // Limit to top 10 relevant entries\n  \n  return relevantKB.map(item => \n    `Q: ${item.question_pt || item.question_en || item.title}\\nA: ${item.answer_pt || item.answer_en || item.content}`\n  ).join('\\n\\n');\n}\n\n// Build conversation context from history\nfunction buildConversationContext(history) {\n  if (!Array.isArray(history) || history.length === 0) return '';\n  \n  // Reverse to get most recent first, then take up to 3 turns\n  return history.slice(0, 3).reverse().map(msg => \n    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.message}`\n  ).join('\\n');\n}\n\n// Enhanced system prompts based on the document\nconst systemPrompts = {\n  pt: `Voc√™ √© um assistente de IA bil√≠ngue profissional e amig√°vel para uma startup de IA.\nResponda em portugu√™s (PT-PT) de forma concisa (m√°ximo 150 palavras), profissional mas acess√≠vel.\n\nDiretrizes:\n- Seja √∫til, preciso e honesto\n- Se n√£o souber algo, admita e ofere√ßa alternativas\n- Para agendamentos, extraia NOME, EMAIL, DATA, HORA e o TIPO DE SERVI√áO do utilizador e responda APENAS com o seguinte formato JSON: {\"appointment_details\": {\"name\": \"<nome>\", \"email\": \"<email>\", \"date\": \"<AAAA-MM-DD>\", \"time\": \"<HH:MM>\", \"type\": \"<tipo>\", \"notes\": \"<notas>\"}}. Para outras quest√µes, responda normalmente em portugu√™s (PT-PT).\n\nContexto da empresa:\n{{ KNOWLEDGE_CONTEXT }}\n\nHist√≥rico da conversa:\n{{ CONVERSATION_CONTEXT }}\n\nResponda √† seguinte mensagem do utilizador:`,\n  \n  en: `You are a professional and friendly bilingual AI assistant for an AI startup.\nRespond in English concisely (max 150 words), professional yet approachable.\n\nGuidelines:\n- Be helpful, accurate, and honest\n- If unsure, admit it and offer alternatives\n- For appointments, extract NAME, EMAIL, DATE, TIME, and SERVICE TYPE from the user and respond ONLY with the following JSON format: {\"appointment_details\": {\"name\": \"<name>\", \"email\": \"<email>\", \"date\": \"<YYYY-MM-DD>\", \"time\": \"<HH:MM>\", \"type\": \"<type>\", \"notes\": \"<notes>\"}}. For all other queries, respond normally in English.\n\nCompany context:\n{{ KNOWLEDGE_CONTEXT }}\n\nConversation history:\n{{ CONVERSATION_CONTEXT }}\n\nRespond to the following user message:`\n};\n\n// Build final prompt with context and history\nconst knowledgeContext = buildKnowledgeContext(knowledgeBaseResponse, detectedLanguage);\nconst conversationContext = buildConversationContext(conversationHistoryResponse);\n\nconst systemPrompt = systemPrompts[detectedLanguage]\n  .replace('{{ KNOWLEDGE_CONTEXT }}', knowledgeContext || 'No specific company information available.')\n  .replace('{{ CONVERSATION_CONTEXT }}', conversationContext || 'No previous conversation.');\n\nconst fullPrompt = `${systemPrompt}\\n\\nUser: ${sanitizedMessage}`;\n\n// Prepare API request body for Ollama (Llama3.2)\nconst requestBody = {\n  model: process.env.LLAMA_MODEL || 'llama3.2:latest',\n  messages: [\n    {\n      role: 'system',\n      content: systemPrompt\n    },\n    {\n      role: 'user',\n      content: sanitizedMessage\n    }\n  ],\n  stream: false,\n  options: {\n    temperature: 0.7,\n    max_tokens: 500,\n    top_p: 0.9,\n    stop: ['User:', 'Assistant:', 'Human:'] // Stop generation at these markers\n  }\n};\n\nreturn [{\n  json: {\n    ...$json,\n    aiRequest: requestBody,\n    hasKnowledge: knowledgeBaseResponse.length > 0,\n    hasHistory: conversationHistoryResponse.length > 0,\n    fullPrompt // Include full prompt for debugging/logging\n  }\n}];"
      },
      "name": "Llama3.2 AI Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        750
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.OLLAMA_URL || 'http://localhost:11434' }}/api/chat",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3,
            "maxTimeout": 60000
          },
          "response": { "neverError": true }
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ $json.aiRequest }}"
      },
      "name": "Llama API Call",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        1800,
        750
      ]
    },
    {
      "parameters": {
        "conditions": [
          {
            "value1": "={{ $json.statusCode }}",
            "operator": "notEqual",
            "value2": 200
          }
        ]
      },
      "name": "AI Error Checker",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2000,
        750
      ]
    },
    {
      "parameters": {
        "functionCode": "// GDPR Error Handler: Provides multilingual fallback responses and prepares admin notifications.\n\nconst previousData = $input.first().json;\nconst { detectedLanguage, sessionId, originalMessage, statusCode, statusText, body } = previousData;\n\n// Attempt to get a more specific error message from the body\nlet errorDetail = body?.error || body?.message || 'Unknown API Error';\n\nconst error = `HTTP Error ${statusCode}: ${statusText}. Detail: ${errorDetail}`;\n\n// Comprehensive fallback responses in both languages\nconst fallbackResponses = {\n  pt: [\n    'Pe√ßo desculpa, mas estou com dificuldades t√©cnicas neste momento. Pode tentar novamente em alguns minutos?',\n    'Lamento, mas n√£o consegui processar o seu pedido. Por favor, tente reformular a sua mensagem.',\n    'Estou temporariamente indispon√≠vel. Por favor, contacte-nos diretamente se for urgente.',\n    'Ocorreu um erro t√©cnico. A nossa equipa foi notificada e iremos resolver brevemente.'\n  ],\n  en: [\n    'I apologize, but I am experiencing technical difficulties at the moment. Could you try again in a few minutes?',\n    'Sorry, I could not process your request. Please try rephrasing your message.',\n    'I am temporarily unavailable. Please contact us directly if this is urgent.',\n    'A technical error occurred. Our team has been notified and will resolve this shortly.'\n  ]\n};\n\n// Select appropriate fallback response based on detected language\nconst responses = fallbackResponses[detectedLanguage] || fallbackResponses['en'];\nconst fallbackResponse = responses[Math.floor(Math.random() * responses.length)];\n\n// Generate a simple UUID for error tracking\nfunction generateSimpleUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconst errorId = generateSimpleUUID();\n\n// Enhanced error context for monitoring (without sensitive user data)\nconst errorContext = {\n  timestamp: new Date().toISOString(),\n  sessionId,\n  language: detectedLanguage,\n  messageLength: originalMessage?.length || 0,\n  errorType: `AI_API_CALL_FAILED_${statusCode}`,\n  errorDetail: error,\n  userAgent: previousData.hashedUserAgent || 'unknown',\n  errorId: errorId\n};\n\nconsole.error('AI Chatbot Error:', JSON.stringify(errorContext, null, 2));\n\nreturn [{\n  json: {\n    response: fallbackResponse,\n    language: detectedLanguage,\n    sessionId,\n    isError: true,\n    errorHandled: true,\n    timestamp: new Date().toISOString(),\n    errorContext\n  }\n}];"
      },
      "name": "GDPR Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        900
      ]
    },
    {
      "parameters": {
        "toEmail": "={{ $env.ADMIN_EMAIL }}",
        "fromEmail": "={{ $env.SMTP_FROM_EMAIL }}",
        "subject": "üö® Critical AI Chatbot Error - ID: {{ $json.errorContext.errorId }}",
        "text": "Critical error occurred in AI Chatbot System:\\n\\nError ID: {{ $json.errorContext.errorId }}\\nTimestamp: {{ $json.errorContext.timestamp }}\\nSession ID: {{ $json.errorContext.sessionId }}\\nLanguage: {{ $json.errorContext.language }}\\nError Type: {{ $json.errorContext.errorType }}\\nError Detail: {{ $json.errorContext.errorDetail }}\\nUser Agent Hash: {{ $json.errorContext.userAgent }}\\n\\nPlease investigate immediately.\\n\\nThis is an automated alert from the AI Chatbot monitoring system.",
        "options": {
          "priority": "high"
        }
      },
      "name": "Critical Error Notification",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "credentials": {
        "smtp": {
          "id": "smtpCreds",
          "name": "SMTP Account"
        }
      },
      "position": [
        2400,
        900
      ]
    },
    {
      "parameters": {
        "functionCode": "// Process AI Response: Extracts AI message, caches it, and detects appointment intent.\n// Also prepares data for saving user and AI messages to Supabase.\n\nconst previousData = $input.first().json;\nconst aiResponseData = previousData.body; // Full response from Ollama API\n\n// Extract AI response content\nconst aiResponseContent = aiResponseData?.message?.content || aiResponseData?.response || '';\nconst { detectedLanguage, sessionId, cacheKey, originalMessage, messageHash } = previousData;\n\n// Clean up AI response: Remove leading roles (e.g., 'Assistant:'), newlines followed by roles\nconst cleanResponse = aiResponseContent\n  .replace(/^(Assistant:|AI:|Bot:)\\s*/i, '') // Remove prefixes like 'Assistant:'\n  .replace(/\\n\\s*(User:|Human:)/i, '') // Remove trailing user prompts\n  .trim();\n\n// Cache the response using the in-memory cache\nif (typeof global !== 'undefined' && global.chatbotCache && cacheKey) {\n  const cacheData = {\n    response: cleanResponse,\n    language: detectedLanguage,\n    sessionId,\n    originalMessage,\n    cachedAt: new Date().toISOString()\n  };\n  \n  global.chatbotCache.set(cacheKey, cacheData);\n  global.cacheTimestamps.set(cacheKey, Date.now());\n}\n\n// Enhanced intent detection for appointment scheduling (checks both original message and AI response)\nconst appointmentKeywords = {\n  pt: /\\b(agendar|marcar|reuni√£o|encontro|consulta|hora\\s+marcada|data\\s+dispon√≠vel|criar\\s+evento)\\b/i,\n  en: /\\b(schedule|book|appointment|meeting|consultation|available\\s+time|book\\s+slot|create\\s+event)\\b/i\n};\n\n// Check if AI response is in the expected JSON format for appointments\nlet hasAppointmentIntent = false;\nlet appointmentData = null;\n\ntry {\n  const parsedResponse = JSON.parse(cleanResponse);\n  if (parsedResponse.appointment_details) {\n    appointmentData = parsedResponse.appointment_details;\n    hasAppointmentIntent = true;\n    // Optionally, re-format AI response if it's JSON and not meant for direct display\n    // For example, if it's a confirmation message after JSON extraction\n    // aiResponse = detectedLanguage === 'pt' \n    //   ? `Obrigado! A processar o seu pedido de agendamento para ${appointmentData.email || ''}.` \n    //   : `Thank you! Processing your appointment request for ${appointmentData.email || ''}.`;\n  }\n} catch (e) {\n  // Not a JSON response, proceed with keyword detection\n}\n\n// Fallback keyword detection if not JSON or if JSON didn't contain appointment_details\nif (!hasAppointmentIntent) {\n    hasAppointmentIntent = \n      appointmentKeywords.pt.test(originalMessage) ||\n      appointmentKeywords.en.test(originalMessage) ||\n      appointmentKeywords.pt.test(cleanResponse) ||\n      appointmentKeywords.en.test(cleanResponse);\n}\n\nreturn [{\n  json: {\n    ...previousData,\n    response: cleanResponse,\n    hasAppointmentIntent: hasAppointmentIntent,\n    appointmentData: appointmentData, // Will be null if not detected as JSON appointment\n    fromCache: false, // This node processes new AI responses, so not from cache here\n    timestamp: new Date().toISOString(),\n    // The `confidence` might come from the LLM response itself, or be an assumed value.\n    // Using a default if not explicitly returned by the LLM in `aiResponseData`.\n    confidence: aiResponseData?.message?.confidence || previousData.confidence || 0.8,\n    // Ensure messageHash is consistent for saving to DB\n    messageHash: messageHash // Ensure we carry this hash from language detection\n  }\n}];"
      },
      "name": "Process AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2200,
        750
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations",
        "options": {
          "timeout": 5000,
          "headers": {
            "Prefer": "return=minimal"
          }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"role\": \"user\",\n  \"message\": \"{{ $json.originalMessage }}\",\n  \"language\": \"{{ $json.detectedLanguage }}\",\n  \"message_hash\": \"{{ $json.messageHash || '' }}\",\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "name": "Save User Message",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2400,
        750
      ]
    },
    {
      "parameters": {
        "conditions": [
          {
            "value1": "={{ $json.hasAppointmentIntent }}",
            "operator": "equals",
            "value2": true
          }
        ]
      },
      "name": "Intent Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2600,
        750
      ]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced Appointment Extractor: Extracts detailed appointment info using comprehensive regex.\n// This is an advanced extraction node combining user message and AI response.\n\nconst { originalMessage, response, detectedLanguage, sessionId } = $json;\nconst textToParse = `${originalMessage} ${response}`.toLowerCase();\n\n// Comprehensive regex patterns for extracting appointment information\nconst patterns = {\n  email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n  phone: /(?:\\+351|00351|351)?\\s*[0-9]{2,3}\\s*[0-9]{3}\\s*[0-9]{3,4}|[0-9]{9}/g,\n  \n  names: {\n    pt: /(?:meu nome √©|sou o|sou a|chamo-me|nome:?)\\s+([A-Z√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß]+(?:\\s+[A-Z√Å√Ä√Ç√É√â√ä√ç√ì√î√ï√ö√á][a-z√°√†√¢√£√©√™√≠√≥√¥√µ√∫√ß]+)*)/gi,\n    en: /(?:my name is|i am|i'm|name:?)\\s+([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)/gi\n  },\n  \n  dates: {\n    pt: /(?:dia|data|em)\\s*(\\d{1,2})[\\/-](\\d{1,2})[\\/-](\\d{2,4})|(?:pr√≥xima|pr√≥ximo)\\s+(segunda|ter√ßa|quarta|quinta|sexta|segunda-feira|ter√ßa-feira|quarta-feira|quinta-feira|sexta-feira)/gi,\n    en: /(?:on|date)\\s*(\\d{1,2})[\\/-](\\d{1,2})[\\/-](\\d{2,4})|(?:next)\\s+(monday|tuesday|wednesday|thursday|friday)/gi\n  },\n  \n  times: {\n    pt: /(?:√†s|hora|horas)\\s*(\\d{1,2})(?:[:h](\\d{2}))?\\s*(?:da\\s+)?(manh√£|tarde|manha|noite)?/gi, // Added noite\n    en: /(?:at)\\s*(\\d{1,2})(?:[:.](\\d{2}))?\\s*(am|pm|AM|PM)?/gi\n  },\n  \n  services: {\n    pt: /(?:consulta|reuni√£o|meeting|sess√£o|servi√ßo|tipo)\\s+(?:de\\s+)?(\\w+)/gi,\n    en: /(?:consultation|meeting|session|service|type)\\s+(?:for\\s+)?(\\w+)/gi\n  }\n};\n\n// Extraction helper functions\nconst extractAll = (text, pattern) => {\n  const matches = [];\n  let match;\n  while ((match = pattern.exec(text)) !== null) {\n    matches.push(match[1] || match[0]); // Capture group 1 or full match\n  }\n  return [...new Set(matches)]; // Return unique matches\n};\n\nconst extractNames = (text, lang) => {\n  const pattern = patterns.names[lang] || patterns.names.en;\n  const matches = [];\n  let match;\n  while ((match = pattern.exec(text)) !== null) {\n    if (match[1]) matches.push(match[1].trim());\n  }\n  return [...new Set(matches)];\n};\n\nconst extractDates = (text, lang) => {\n  const pattern = patterns.dates[lang] || patterns.dates.en;\n  const matches = [];\n  let match;\n  while ((match = pattern.exec(text)) !== null) {\n    if (match[1] && match[2] && match[3]) {\n      // DD/MM/YYYY or DD-MM-YYYY\n      const year = parseInt(match[3]) < 100 ? 2000 + parseInt(match[3]) : parseInt(match[3]);\n      matches.push(`${year}-${match[2].padStart(2, '0')}-${match[1].padStart(2, '0')}`);\n    } else if (match[4]) {\n      // Day of week (e.g., "next monday") - requires further processing for exact date\n      matches.push(match[4].toLowerCase());\n    }\n  }\n  return [...new Set(matches)];\n};\n\nconst extractTimes = (text, lang) => {\n  const pattern = patterns.times[lang] || patterns.times.en;\n  const matches = [];\n  let match;\n  while ((match = pattern.exec(text)) !== null) {\n    let hour = parseInt(match[1]);\n    const minute = match[2] ? parseInt(match[2]) : 0;\n    const period = match[3] ? match[3].toLowerCase() : '';\n\n    if (period === 'pm' && hour < 12) hour += 12; // Convert to 24-hour format\n    if (period === 'am' && hour === 12) hour = 0; // 12 AM is 00:00\n    if (period === 'manha' && hour >= 12) hour -= 12; // Adjust for morning\n    if (period === 'tarde' && hour < 12) hour += 12; // Adjust for afternoon\n    if (period === 'noite' && hour < 12) hour += 12; // Adjust for evening\n\n    matches.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);\n  }\n  return [...new Set(matches)];\n};\n\n// Perform extraction\nconst emails = extractAll(textToParse, patterns.email);\nconst phones = extractAll(textToParse, patterns.phone);\nconst names = extractNames(textToParse, detectedLanguage);\nconst dates = extractDates(textToParse, detectedLanguage); //YYYY-MM-DD or day of week\nconst times = extractTimes(textToParse, detectedLanguage); // HH:MM (24-hour)\nconst services = extractAll(textToParse, patterns.services[detectedLanguage] || patterns.services.en);\n\n// Prioritize appointment data from AI JSON if available\nlet appointmentData = $json.appointmentData || {};\nappointmentData.name = appointmentData.name || (names.length > 0 ? names[0] : null);\nappointmentData.email = appointmentData.email || (emails.length > 0 ? emails[0] : null);\nappointmentData.type = appointmentData.type || (services.length > 0 ? services[0] : 'general');\nappointmentData.date = appointmentData.date || (dates.length > 0 ? dates[0] : null);\nappointmentData.time = appointmentData.time || (times.length > 0 ? times[0] : null);\n\n// Validate if enough data was extracted\nconst hasValidData = !!appointmentData.name && !!appointmentData.email && !!appointmentData.date && !!appointmentData.time;\n\nreturn [{\n  json: {\n    ...$json,\n    extractedAppointmentDetails: {\n      name: appointmentData.name,\n      email: appointmentData.email,\n      type: appointmentData.type,\n      date: appointmentData.date,\n      time: appointmentData.time,\n      notes: appointmentData.notes || '', // From AI JSON, if any\n      language: detectedLanguage,\n      phones: phones.length > 0 ? phones[0] : null // Keep first phone if multiple\n    },\n    hasValidData: hasValidData,\n    rawExtractedData: { emails, phones, names, dates, times, services }\n  }\n}];"
      },
      "name": "Enhanced Appointment Extractor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2800,
        450
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations",
        "options": {
          "timeout": 5000,
          "headers": {
            "Prefer": "return=minimal"
          }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"role\": \"assistant\",\n  \"message\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.detectedLanguage }}\",\n  \"confidence\": {{ $json.confidence || 0.8 }},\n  \"from_cache\": {{ $json.fromCache || false }},\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "name": "Save AI Response",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        2800,
        850
      ]
    },
    {
      "parameters": {
        "conditions": [
          {
            "value1": "={{ $json.hasValidData }}",
            "operator": "equals",
            "value2": true
          }
        ]
      },
      "name": "Appointment Data Validator",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        3000,
        450
      ]
    },
    {
      "parameters": {
        "functionCode": "// Nextcloud Calendar Creator: Prepares VEVENT data for Nextcloud Calendar API.\n// Uses btoa for Base64 encoding for compatibility. Handles Lisbon timezone.\n\nconst appointmentData = $json.extractedAppointmentDetails;\nconst { name, email, type, date, time, language } = appointmentData;\nconst sessionId = $json.sessionId;\n\n// Helper to generate a simple UUID for event IDs\nfunction generateSimpleUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconst eventId = `ai-appt-${generateSimpleUUID()}`;\n\n// Combine date and time for initial Date object. Handle potential nulls.\nconst datePart = date || new Date().toISOString().split('T')[0];\nconst timePart = time || '14:00'; // Default to 2 PM if time is missing\n\nlet eventDateTime = new Date(`${datePart}T${timePart}:00`);\n\n// --- Complex Timezone Handling for Europe/Lisbon --- \n// This is crucial for VEVENT DTSTART;TZID to be correct.\n// We parse the date/time string, then construct a new Date object assuming it's in the target timezone,\n// then get its UTC representation for VEVENT. \n\nconst targetTimeZone = 'Europe/Lisbon';\nconst options = { year: 'numeric', month: '2-digit', day: '2-digit',\n                  hour: '2-digit', minute: '2-digit', second: '2-digit',\n                  hourCycle: 'h23', timeZone: targetTimeZone };\n\n// Get parts of the date/time string formatted for Lisbon\nconst parts = new Intl.DateTimeFormat('en-CA', options).formatToParts(eventDateTime);\nconst year = parts.find(p => p.type === 'year')?.value;\nconst month = parts.find(p => p.type === 'month')?.value;\nconst day = parts.find(p => p.type === 'day')?.value;\nconst hour = parts.find(p => p.type === 'hour')?.value;\nconst minute = parts.find(p => p.type === 'minute')?.value;\nconst second = parts.find(p => p.type === 'second')?.value;\n\n// Construct a Date object that effectively IS the date/time in Lisbon's local time\nconst dateInLisbonString = `${year}-${month}-${day}T${hour}:${minute}:${second}`; \nconst dateInLisbon = new Date(dateInLisbonString);\n\n// Now, convert this Lisbon-local date to UTC for the VEVENT DTSTART/DTEND (which expects UTC with 'Z')\n// This requires manually adjusting for the *local* timezone offset to get the *true* UTC time.\nconst utcDateTime = new Date(dateInLisbon.getTime() - dateInLisbon.getTimezoneOffset() * 60000);\n\n// Event duration (default to 1 hour if not specified)\nconst startDateTime = utcDateTime; // This is the UTC date for DTSTART\nconst endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // 1 hour later\n\n// Format dates for VEVENT (e.g., 20250607T100000Z)\nfunction formatVEventDate(date) {\n  return date.toISOString().replace(/[-:]/g, '').replace(/\\.\\d{3}/, ''); // Remove milliseconds and colons/hyphens\n}\n\n// Build event title and description\nconst eventTitle = language === 'pt' \n  ? `Agendamento: ${type} - ${name}`\n  : `Appointment: ${type} - ${name}`;\n\nconst eventDescription = language === 'pt'\n  ? `Agendamento via chatbot\\nTipo: ${type}\\nCliente: ${name}\\nEmail: ${email}\\nSess√£o: ${sessionId}\\nNotas: ${appointmentData.notes || 'N/A'}`\n  : `Appointment via chatbot\\nType: ${type}\\nClient: ${name}\\nEmail: ${email}\\nSession: ${sessionId}\\nNotes: ${appointmentData.notes || 'N/A'}`;\n\n// Build VEVENT (RFC 5545 compliant)\n// IMPORTANT: Ensure all \\n are escaped as \\\\n within the string for JSON transfer.\n// DTSTART and DTEND use TZID for timezone awareness instead of Z for UTC directly, and the time is local to that TZID.\nconst vevent = `BEGIN:VCALENDAR\\nVERSION:2.0\\nPRODID:-//AI Chatbot//Appointment Scheduler//EN\\nCALSCALE:GREGORIAN\\nMETHOD:PUBLISH\\nBEGIN:VTIMEZONE\\nTZID:Europe/Lisbon\\nBEGIN:DAYLIGHT\\nTZOFFSETFROM:+0000\\nTZOFFSETTO:+0100\\nTZNAME:WEST\\nDTSTART:19700329T010000\\nRRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\\nEND:DAYLIGHT\\nBEGIN:STANDARD\\nTZOFFSETFROM:+0100\\nTZOFFSETTO:+0000\\nTZNAME:WET\\nDTSTART:19701025T020000\\nRRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\\nEND:STANDARD\\nEND:VTIMEZONE\\nBEGIN:VEVENT\\nUID:${eventId}\\nDTSTAMP:${formatVEventDate(new Date())}\\nDTSTART;TZID=Europe/Lisbon:${formatVEventDate(new Date(startDateTime.getTime() + startDateTime.getTimezoneOffset() * 60000)).slice(0, -1)}\\nDTEND;TZID=Europe/Lisbon:${formatVEventDate(new Date(endDateTime.getTime() + endDateTime.getTimezoneOffset() * 60000)).slice(0, -1)}\\nSUMMARY:${eventTitle}\\nDESCRIPTION:${eventDescription.replace(/\\n/g, '\\\\n')}\\nLOCATION:Online/Office\\nSTATUS:CONFIRMED\\nCLASS:PUBLIC\\nTRANSP:OPAQUE\\n${email ? `ATTENDEE;CN=${name};RSVP=TRUE:mailto:${email}\\n` : ''}ORGANIZER;CN=AI Assistant:mailto:${process.env.BUSINESS_EMAIL || 'admin@company.com'}\\nCATEGORIES:AI-Generated,${type}\\nEND:VEVENT\\nEND:VCALENDAR`;\n\nreturn [{\n  json: {\n    ...$json,\n    vevent,\n    eventTitle,\n    eventDescription,\n    startDateTime: startDateTime.toISOString(),\n    endDateTime: endDateTime.toISOString(),\n    eventId,\n    calendarData: {\n      title: eventTitle,\n      start: startDateTime.toISOString(),\n      end: endDateTime.toISOString(),\n      description: eventDescription,\n      attendees: [email],\n      timezone: targetTimeZone,\n      type: type\n    }\n  }\n}];"
      },
      "name": "Nextcloud Calendar Creator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        450
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.NEXTCLOUD_URL }}/remote.php/dav/calendars/{{ $env.NEXTCLOUD_USER }}/business-appointments/{{ $json.eventId }}.ics",
        "options": {
          "timeout": 10000,
          "response": { "neverError": true }
        },
        "headers": {
          "Content-Type": "text/calendar; charset=utf-8",
          "User-Agent": "AI-Chatbot-Scheduler/1.0"
        },
        "httpMethod": "PUT",
        "sendBody": true,
        "bodyContentType": "raw",
        "body": "={{ $json.vevent }}"
      },
      "name": "Nextcloud Calendar API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "credentials": {
        "httpBasicAuth": {
          "id": "nextcloudAuth",
          "name": "Nextcloud Basic Auth"
        }
      },
      "position": [
        3400,
        450
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/appointments",
        "options": {
          "timeout": 5000,
          "headers": {
            "Prefer": "return=minimal"
          }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "POST",
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"event_id\": \"{{ $json.eventId }}\",\n  \"appointment_type\": \"{{ $json.extractedAppointmentDetails.type }}\",\n  \"user_name\": \"{{ $json.extractedAppointmentDetails.name }}\",\n  \"user_email\": \"{{ $json.extractedAppointmentDetails.email }}\",\n  \"language\": \"{{ $json.extractedAppointmentDetails.language }}\",\n  \"start_datetime\": \"{{ $json.startDateTime }}\",\  \"end_datetime\": \"{{ $json.endDateTime }}\",\n  \"status\": \"pending\",\n  \"notes\": \"{{ $json.extractedAppointmentDetails.notes }}\",\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "name": "Save Appointment to DB",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3600,
        450
      ]
    },
    {
      "parameters": {
        "functionCode": "// Prepare Confirmation Email: Generates email content and ICS attachment for appointment confirmation.\n\nconst inputData = $json;\nconst appointment = inputData.extractedAppointmentDetails;\nconst { eventTitle, startDateTime, icsBody } = inputData;\n\n// Format event time for email body (Lisbon timezone)\nconst eventTimeFormatted = new Date(startDateTime).toLocaleString(inputData.language === 'pt' ? 'pt-PT' : 'en-GB', {timeZone: 'Europe/Lisbon', dateStyle: 'full', timeStyle: 'short'});\n\nconst subject = inputData.language === 'pt' \n  ? `Confirma√ß√£o de Agendamento: ${eventTitle}`\n  : `Appointment Confirmation: ${eventTitle}`;\n\nconst bodyText = inputData.language === 'pt' \n  ? `Ol√° ${appointment.name},\\n\\nO seu agendamento para uma reuni√£o de '${appointment.type}' foi confirmado para ${eventTimeFormatted}.\\n\\nEm anexo encontrar√° o convite para o seu calend√°rio.\\n\\nCom os melhores cumprimentos,`\n  : `Hi ${appointment.name},\\n\\nYour appointment for a '${appointment.type}' meeting has been confirmed for ${eventTimeFormatted}.\\n\\nThe calendar invitation is attached.\\n\\nBest regards,`;\n\nconst emailData = {\n  to: appointment.email,\n  from: process.env.SMTP_FROM_EMAIL,\n  subject: subject,\n  text: bodyText,\n  attachments: [\n    {\n      // Use btoa to base64 encode the ICS body for email attachment\n      content: btoa(icsBody),\n      filename: `${inputData.eventId}.ics`,\n      contentType: 'text/calendar'\n    }\n  ]\n};\n\nreturn [{ json: { ...inputData, emailData } }];"
      },
      "name": "Prepare Confirmation Email",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3800,
        450
      ]
    },
    {
      "parameters": {
        "toEmail": "={{ $json.emailData.to }}",
        "fromEmail": "={{ $json.emailData.from }}",
        "subject": "={{ $json.emailData.subject }}",
        "text": "={{ $json.emailData.text }}",
        "options": {
          "attachments": "={{ $json.emailData.attachments }}"
        }
      },
      "name": "Send Confirmation Email",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "credentials": {
        "smtp": {
          "id": "smtpCreds",
          "name": "SMTP Account"
        }
      },
      "position": [
        4000,
        450
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations",
        "options": {
          "timeout": 5000,
          "headers": {
            "Prefer": "return=minimal"
          }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "POST",
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"role\": \"assistant\",\n  \"message\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.detectedLanguage }}\",\n  \"confidence\": {{ $json.confidence || 0.8 }},\n  \"from_cache\": {{ $json.fromCache || false }},\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "name": "Save AI Response",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3000,
        850
      ]
    },
    {
      "parameters": {
        "functionCode": "// Audit Logger: Prepares an audit log entry for storing in Supabase.\n// Uses a simpler UUID generation as 'crypto' module might not be available in n8n Code nodes.\n\nconst inputData = $json;\n\n// Simple hash for audit log data (non-cryptographic)\nfunction simpleHash(data) {\n    if (!data) return null;\n    let hash = 0;\n    for (let i = 0; i < data.length; i++) {\n        const char = data.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash |= 0;\n    }\n    return Math.abs(hash).toString(16);\n}\n\n// Generate a simple UUID for error tracking\nfunction generateSimpleUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconst auditEntry = {\n  session_id_hash: simpleHash(inputData.sessionId),\n  language: inputData.detectedLanguage,\n  user_message_hash: inputData.messageHash,\n  assistant_response_hash: simpleHash(inputData.response),\n  has_appointment_intent: inputData.hasAppointmentIntent || false,\n  appointment_created: !!inputData.eventId || false,\n  processing_time_ms: Date.now() - new Date(inputData.timestamp).getTime(),\n  ip_hash: inputData.hashedIP,\n  user_agent_hash: inputData.hashedUserAgent,\n  log_id: generateSimpleUUID(),\n  created_at: new Date().toISOString()\n};\n\nreturn [{ json: { ...inputData, auditEntry } }];"
      },
      "name": "Audit Logger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3200,
        850
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/audit_logs",
        "options": {
          "timeout": 5000,
          "headers": {
            "Prefer": "return=minimal"
          }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "POST",
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ $json.auditEntry }}"
      },
      "name": "Save Audit Log",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        3400,
        850
      ]
    },
    {
      "parameters": {
        "functionCode": "// Redis Cache Set: Prepares data to save AI response to Redis cache.\n\nconst inputData = $json;\nconst cacheData = {\n  response: inputData.response,\n  language: inputData.detectedLanguage,\n  sessionId: inputData.sessionId,\n  timestamp: inputData.timestamp\n};\n\n// Redis 'SET' command with expiry (EX) in seconds (10 minutes = 600 seconds)\nconst redisSetRequest = {\n  key: inputData.cacheKey,\n  value: JSON.stringify(cacheData),\n  ex: 600 \n};\n\nreturn [{ json: { ...inputData, redisSetRequest } }];"
      },
      "name": "Redis Cache Set",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3600,
        850
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.REDIS_URL }}/set",
        "options": {
          "response": { "neverError": true }
        },
        "headers": {
          "Content-Type": "application/json"
        },
        "httpMethod": "POST",
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"key\": \"{{ $json.redisSetRequest.key }}\",\n  \"value\": \"{{ $json.redisSetRequest.value }}\",\n  \"ex\": {{ $json.redisSetRequest.ex }}\n}"
      },
      "name": "Execute Redis Set",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "credentials": {
        "httpHeaderAuth": {
          "id": "redisAuth",
          "name": "Redis API Key"
        }
      },
      "position": [
        3800,
        850
      ]
    },
    {
      "parameters": {
        "functionCode": "// API Response Formatter: Formats the final JSON response for the webhook.\n\nconst inputData = $json;\n\nconst response = {\n  success: !inputData.isError,\n  data: {\n    message: inputData.response,\n    language: inputData.detectedLanguage,\n    sessionId: inputData.sessionId,\n    hasAppointmentIntent: inputData.hasAppointmentIntent || false,\n    appointmentCreated: !!inputData.eventId || false,\n    appointmentDetails: inputData.calendarData || null\n  },\n  metadata: {\n    processingTimeMs: Date.now() - new Date(inputData.timestamp).getTime(),\n    cached: !!inputData.fromCache,\n    timestamp: new Date().toISOString()\n  }\n};\n\nreturn [{ json: response }];"
      },
      "name": "API Response Formatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4000,
        850
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "name": "API Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        4200,
        850
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.detectedLanguage }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"fromCache\": true\n}"
      },
      "name": "Cached Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1000,
        650
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"error\": \"Message is empty\",\n  \"language\": \"en\",\n  \"timestamp\": \"{{ new Date().toISOString() }}\",\n  \"sessionId\": \"{{ $json.sessionId || 'unknown' }}\"\n}"
      },
      "name": "Empty Message Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        800,
        900
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"error\": true,\n  \"errorHandled\": true\n}"
      },
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2600,
        900
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.detectedLanguage }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"appointmentCreated\": true,\n  \"appointmentDetails\": {\n    \"eventId\": \"{{ $json.eventId }}\",\n    \"title\": \"{{ $json.eventTitle }}\",\n    \"startTime\": \"{{ $json.startDateTime }}\",\n    \"endTime\": \"{{ $json.endDateTime }}\",\n    \"type\": \"{{ $json.extractedAppointmentDetails.type }}\",\n    \"userEmail\": \"{{ $json.extractedAppointmentDetails.email }}\"\n  }\n}"
      },
      "name": "Appointment Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        4200,
        450
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 2 * * *"
            }
          ]
        }
      },
      "name": "Daily Maintenance Trigger",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        200,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced GDPR-compliant daily maintenance preparation.\n// Uses a simpler UUID generation as 'crypto' module might not be available in n8n Code nodes.\n\n// Generate a simple UUID if crypto.randomUUID is not available\nfunction generateSimpleUUID() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\n// Calculate cleanup dates\nconst now = new Date();\nconst thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();\nconst ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000).toISOString();\n\n// Clear in-memory cache safely if it exists (for a truly persistent solution, this would be Redis CLEAR)\nif (typeof global !== 'undefined' && global.chatbotCache) {\n  global.chatbotCache.clear();\n  global.cacheTimestamps.clear();\n  console.log('In-memory cache cleared during maintenance.');\n}\n\n// Define maintenance tasks with enhanced metadata\nconst maintenanceTasks = {\n  conversationCleanup: {\n    table: 'conversations',\n    cutoffDate: thirtyDaysAgo,\n    description: 'Delete conversations older than 30 days (GDPR compliance)',\n    priority: 'high'\n  },\n  appointmentCleanup: {\n    table: 'appointments', \n    cutoffDate: ninetyDaysAgo,\n    description: 'Delete completed appointments older than 90 days',\n    priority: 'medium'\n  },\n  cacheCleanup: {\n    description: 'Clear in-memory cache and reset counters',\n    completed: true,\n    priority: 'low'\n  }\n};\n\nreturn [{\n  json: {\n    maintenanceTasks,\n    timestamp: now.toISOString(),\n    timezone: 'Europe/Lisbon',\n    maintenanceId: generateSimpleUUID(),\n    status: 'ready'\n  }\n}];"
      },
      "name": "Enhanced Maintenance Preparation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        300
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations?created_at=lt.{{ $json.maintenanceTasks.conversationCleanup.cutoffDate }}",
        "options": {
          "timeout": 30000,
          "headers": {
            "Prefer": "return=minimal"
          },
          "response": { "neverError": true }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "DELETE"
      },
      "name": "Cleanup Old Conversations",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        600,
        300
      ]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/appointments?created_at=lt.{{ $json.maintenanceTasks.appointmentCleanup.cutoffDate }}",
        "options": {
          "timeout": 30000,
          "headers": {
            "Prefer": "return=minimal"
          },
          "response": { "neverError": true }
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "DELETE"
      },
      "name": "Cleanup Old Appointments",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [
        800,
        300
      ]
    },
    {
      "parameters": {
        "functionCode": "// Enhanced Maintenance Report: Generates a summary report of daily maintenance tasks.\n\nconst maintenanceData = $input.first().json;\nconst conversationCleanupResult = $input.item(1).json;\nconst appointmentCleanupResult = $input.item(2).json;\n\n// Function to get task status based on HTTP response\nfunction getTaskStatus(result) {\n  if (result.error) return 'failed';\n  if (result.statusCode && result.statusCode >= 200 && result.statusCode < 300) return 'completed';\n  return 'unknown'; // Default if no clear success/fail\n}\n\n// Extract records affected from 'count' or 'body.count' if present\nfunction getRecordsAffected(result) {\n  return result.body?.count || result.count || 0;\n}\n\nconst report = {\n  maintenanceId: maintenanceData.maintenanceId,\n  timestamp: new Date().toISOString(),\n  timezone: maintenanceData.timezone,\n  duration: {\n    start: maintenanceData.timestamp,\n    end: new Date().toISOString()\n  },\n  tasks: {\n    conversationCleanup: {\n      status: getTaskStatus(conversationCleanupResult),\n      recordsAffected: getRecordsAffected(conversationCleanupResult),\n      error: conversationCleanupResult.error || conversationCleanupResult.body?.message || null,\n      cutoffDate: maintenanceData.maintenanceTasks.conversationCleanup.cutoffDate\n    },\n    appointmentCleanup: {\n      status: getTaskStatus(appointmentCleanupResult),\n      recordsAffected: getRecordsAffected(appointmentCleanupResult),\n      error: appointmentCleanupResult.error || appointmentCleanupResult.body?.message || null,\n      cutoffDate: maintenanceData.maintenanceTasks.appointmentCleanup.cutoffDate\n    },\n    cacheCleanup: {\n      status: 'completed',\n      description: 'In-memory cache cleared successfully'\n    }\n  },\n  summary: {\n    totalTasksScheduled: 3,\n    totalTasksCompleted: [\n      getTaskStatus(conversationCleanupResult) === 'completed' ? 1 : 0,\n      getTaskStatus(appointmentCleanupResult) === 'completed' ? 1 : 0,\n      1 // cache always succeeds as it's in-memory\n    ].reduce((a, b) => a + b, 0),\n    totalTasksFailed: [\n      getTaskStatus(conversationCleanupResult) === 'failed' ? 1 : 0,\n      getTaskStatus(appointmentCleanupResult) === 'failed' ? 1 : 0\n    ].reduce((a, b) => a + b, 0),\n    totalRecordsDeleted: getRecordsAffected(conversationCleanupResult) + getRecordsAffected(appointmentCleanupResult)\n  }\n};\n\n// Add overall status\nreport.overallStatus = report.summary.totalTasksFailed === 0 ? 'success' : 'partial_failure';\n\nreturn [{\n  json: report\n}];"
      },
      "name": "Enhanced Maintenance Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1000,
        300
      ]
    },
    {
      "parameters": {
        "toEmail": "={{ $env.ADMIN_EMAIL }}",
        "fromEmail": "={{ $env.SMTP_FROM_EMAIL }}",
        "subject": "{{ $json.overallStatus === 'success' ? '‚úÖ' : '‚ö†Ô∏è' }} Daily Maintenance Report - AI Chatbot ({{ $json.maintenanceId }})",
        "text": "Daily maintenance completed for AI Chatbot System:\\n\\n=== MAINTENANCE SUMMARY ===\\nMaintenance ID: {{ $json.maintenanceId }}\\nOverall Status: {{ $json.overallStatus }}\\nTimestamp: {{ $json.timestamp }}\\nTimezone: {{ $json.timezone }}\\nStart Time: {{ $json.duration.start }}\\nEnd Time: {{ $json.duration.end }}\\n\\n=== PERFORMANCE METRICS ===\\nTasks Scheduled: {{ $json.summary.totalTasksScheduled }}\\nTasks Completed: {{ $json.summary.totalTasksCompleted }}/{{ $json.summary.totalTasksScheduled }}\\nTasks Failed: {{ $json.summary.totalTasksFailed }}\\nTotal Records Deleted: {{ $json.summary.totalRecordsDeleted }}\\n\\n=== CONVERSATION CLEANUP ===\\nStatus: {{ $json.tasks.conversationCleanup.status }}\\nRecords Deleted: {{ $json.tasks.conversationCleanup.recordsAffected }}\\nCutoff Date: {{ $json.tasks.conversationCleanup.cutoffDate }}\\nError: {{ $json.tasks.conversationCleanup.error || 'None' }}\\n\\n=== APPOINTMENT CLEANUP ===\\nStatus: {{ $json.tasks.appointmentCleanup.status }}\\nRecords Deleted: {{ $json.tasks.appointmentCleanup.recordsAffected }}\\nCutoff Date: {{ $json.tasks.appointmentCleanup.cutoffDate }}\\nError: {{ $json.tasks.appointmentCleanup.error || 'None' }}\\n\\n=== CACHE CLEANUP ===\\nStatus: {{ $json.tasks.cacheCleanup.status }}\\nDescription: {{ $json.tasks.cacheCleanup.description }}\\n\\n---\\nThis is an automated report from the AI Chatbot maintenance system.\\nReport generated at: {{ $json.timestamp }}",
        "options": {}
      },
      "name": "Enhanced Maintenance Email Report",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "credentials": {
        "smtp": {
          "id": "smtpCreds",
          "name": "SMTP Account"
        }
      },
      "position": [
        1200,
        300
      ]
    }
  ],
  "connections": {
    "Master Webhook": {
      "main": [
        [
          "Security Validator",
          0
        ]
      ]
    },
    "Security Validator": {
      "main": [
        [
          "Language Detection",
          0
        ]
      ]
    },
    "Language Detection": {
      "main": [
        [
          "Cache Check Router",
          0
        ]
      ]
    },
    "Cache Check Router": {
      "main": [
        [
          "Cache Checker",
          0
        ]
      ],
      "else": [
        [
          "Empty Message Response",
          0
        ]
      ]
    },
    "Cache Checker": {
      "main": [
        [
          "Cached Response",
          0
        ],
        [
          "Knowledge Base Fetch",
          0
        ]
      ]
    },
    "Knowledge Base Fetch": {
      "main": [
        [
          "Conversation History Fetch",
          0
        ]
      ]
    },
    "Conversation History Fetch": {
      "main": [
        [
          "Llama3.2 AI Processor",
          0
        ]
      ]
    },
    "Llama3.2 AI Processor": {
      "main": [
        [
          "Llama API Call",
          0
        ]
      ]
    },
    "Llama API Call": {
      "main": [
        [
          "AI Error Checker",
          0
        ]
      ]
    },
    "AI Error Checker": {
      "main": [
        [
          "Process AI Response",
          0
        ]
      ],
      "else": [
        [
          "GDPR Error Handler",
          0
        ]
      ]
    },
    "GDPR Error Handler": {
      "main": [
        [
          "Critical Error Notification",
          0
        ],
        [
          "Error Response",
          0
        ]
      ]
    },
    "Process AI Response": {
      "main": [
        [
          "Save User Message",
          0
        ]
      ]
    },
    "Save User Message": {
      "main": [
        [
          "Intent Router",
          0
        ]
      ]
    },
    "Intent Router": {
      "main": [
        [
          "Enhanced Appointment Extractor",
          0
        ]
      ],
      "else": [
        [
          "Save AI Response",
          0
        ]
      ]
    },
    "Enhanced Appointment Extractor": {
      "main": [
        [
          "Appointment Data Validator",
          0
        ]
      ]
    },
    "Save AI Response": {
      "main": [
        [
          "Audit Logger",
          0
        ]
      ]
    },
    "Appointment Data Validator": {
      "main": [
        [
          "Nextcloud Calendar Creator",
          0
        ]
      ],
      "else": [
        [
          "Save AI Response",
          0
        ]
      ]
    },
    "Nextcloud Calendar Creator": {
      "main": [
        [
          "Nextcloud Calendar API",
          0
        ]
      ]
    },
    "Nextcloud Calendar API": {
      "main": [
        [
          "Save Appointment to DB",
          0
        ]
      ]
    },
    "Save Appointment to DB": {
      "main": [
        [
          "Prepare Confirmation Email",
          0
        ]
      ]
    },
    "Prepare Confirmation Email": {
      "main": [
        [
          "Send Confirmation Email",
          0
        ]
      ]
    },
    "Send Confirmation Email": {
      "main": [
        [
          "Appointment Response",
          0
        ]
      ]
    },
    "Audit Logger": {
      "main": [
        [
          "Save Audit Log",
          0
        ]
      ]
    },
    "Save Audit Log": {
      "main": [
        [
          "Redis Cache Set",
          0
        ]
      ]
    },
    "Redis Cache Set": {
      "main": [
        [
          "Execute Redis Set",
          0
        ]
      ]
    },
    "Execute Redis Set": {
      "main": [
        [
          "API Response Formatter",
          0
        ]
      ]
    },
    "API Response Formatter": {
      "main": [
        [
          "API Response",
          0
        ]
      ]
    },
    "Daily Maintenance Trigger": {
      "main": [
        [
          "Enhanced Maintenance Preparation",
          0
        ]
      ]
    },
    "Enhanced Maintenance Preparation": {
      "main": [
        [
          "Cleanup Old Conversations",
          0
        ]
      ]
    },
    "Cleanup Old Conversations": {
      "main": [
        [
          "Cleanup Old Appointments",
          0
        ]
      ]
    },
    "Cleanup Old Appointments": {
      "main": [
        [
          "Enhanced Maintenance Report",
          0
        ]
      ]
    },
    "Enhanced Maintenance Report": {
      "main": [
        [
          "Enhanced Maintenance Email Report",
          0
        ]
      ]
    }
  ],
  "name": "Enhanced Bilingual AI Chatbot System",
  "active": false,
  "id": "enhanced-bilingual-ai-chatbot-system-workflow",
  "meta": {
    "workflow": {
      "tags": [
        {
          "id": "chatbot",
          "name": "AI Chatbot"
        },
        {
          "id": "production",
          "name": "Production Ready"
        },
        {
          "id": "gdpr",
          "name": "GDPR Compliant"
        },
        {
          "id": "bilingual",
          "name": "Bilingual"
        },
        {
          "id": "self-hosted",
          "name": "Self-Hosted"
        }
      ]
    }
  },
  "settings": {
    "timezone": "Europe/Lisbon",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "enabled": true
    }
  },
  "staticData": {}
}
