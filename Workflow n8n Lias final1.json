{
  "name": "Bilingual AI Chatbot System - Enhanced Production",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "cronExpression",
              "expression": "0 2 * * *"
            }
          ]
        }
      },
      "id": "daily-maintenance-trigger",
      "name": "Daily Maintenance Trigger",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [200, 300]
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ai-chat-webhook",
        "options": {
          "allowedOrigins": "={{ $env.ALLOWED_ORIGINS }}",
          "noResponseBody": false
        },
        "responseMode": "responseNode"
      },
      "id": "master-webhook",
      "name": "Master Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [200, 800]
    },
    {
      "parameters": {
        "jsCode": "// Advanced Language Detection with GDPR Compliance\nconst crypto = require('crypto');\n\n// Extract input data\nconst userMessage = $input.first().json.body?.message?.trim() || '';\nconst userAgent = $input.first().json.headers['user-agent'] || '';\nconst clientIP = $input.first().json.headers['x-forwarded-for'] || $input.first().json.headers['x-real-ip'] || 'unknown';\nconst sessionId = $input.first().json.body?.sessionId || crypto.randomUUID();\n\n// GDPR-compliant hashing\nfunction hashData(data) {\n  return crypto.createHash('sha256').update(data + process.env.HASH_SALT).digest('hex');\n}\n\n// Sanitize message (remove potential XSS, maintain Portuguese characters)\nfunction sanitizeMessage(msg) {\n  return msg.replace(/<[^>]*>/g, '').replace(/[^\\w\\s\\u00C0-\\u017F\\u0080-\\u024F\\u1E00-\\u1EFF.,!?-]/g, '').trim();\n}\n\n// Portuguese language patterns\nconst portuguesePatterns = [\n  /\\b(olá|oi|bom\\s+dia|boa\\s+tarde|boa\\s+noite)\\b/i,\n  /\\b(obrigad[oa]|desculp[ae]|por\\s+favor)\\b/i,\n  /\\b(agendar|marcar|reunião|encontro|consulta)\\b/i,\n  /\\b(sim|não|talvez|claro|certamente)\\b/i,\n  /\\b(como\\s+está|tudo\\s+bem|que\\s+tal)\\b/i,\n  /\\b(empresa|negócio|serviço|produto)\\b/i,\n  /[àáâãçéêíóôõú]/i\n];\n\n// English language patterns\nconst englishPatterns = [\n  /\\b(hello|hi|good\\s+morning|good\\s+afternoon|good\\s+evening)\\b/i,\n  /\\b(thank\\s+you|thanks|sorry|please)\\b/i,\n  /\\b(schedule|book|appointment|meeting|consultation)\\b/i,\n  /\\b(yes|no|maybe|sure|certainly)\\b/i,\n  /\\b(how\\s+are\\s+you|how's\\s+it\\s+going|what's\\s+up)\\b/i,\n  /\\b(company|business|service|product)\\b/i\n];\n\n// Calculate language confidence\nfunction detectLanguage(message) {\n  const ptMatches = portuguesePatterns.reduce((count, pattern) => {\n    return count + (pattern.test(message) ? 1 : 0);\n  }, 0);\n  \n  const enMatches = englishPatterns.reduce((count, pattern) => {\n    return count + (pattern.test(message) ? 1 : 0);\n  }, 0);\n  \n  // Check for Portuguese characters\n  const hasPortugueseChars = /[àáâãçéêíóôõú]/i.test(message);\n  \n  let language = 'en';\n  let confidence = 0.5;\n  \n  if (ptMatches > enMatches || hasPortugueseChars) {\n    language = 'pt';\n    confidence = Math.min(0.9, 0.5 + (ptMatches * 0.1) + (hasPortugueseChars ? 0.2 : 0));\n  } else if (enMatches > ptMatches) {\n    language = 'en';\n    confidence = Math.min(0.9, 0.5 + (enMatches * 0.1));\n  }\n  \n  return { language, confidence };\n}\n\n// Validate input\nif (!userMessage) {\n  return [{
  json: {
    vevent,
    eventTitle,
    eventDescription,
    startDateTime: startDateTime.toISOString(),
    endDateTime: endDateTime.toISOString(),
    appointmentData,
    calendarData: {
      title: eventTitle,
      start: startDateTime.toISOString(),
      end: endDateTime.toISOString(),
      description: eventDescription,
      attendees: emails,
      timezone: 'Europe/Lisbon'
    }
  }
}];"
      },
      "id": "nextcloud-calendar-creator",
      "name": "Nextcloud Calendar Creator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2800, 450]
    },
    {
      "parameters": {
        "url": "={{ $env.NEXTCLOUD_URL }}/remote.php/dav/calendars/{{ $env.NEXTCLOUD_USERNAME }}/business-appointments/",
        "options": {
          "timeout": 10000
        },
        "headers": {
          "Authorization": "Basic {{ $env.NEXTCLOUD_AUTH_HEADER }}",
          "Content-Type": "text/calendar; charset=utf-8"
        },
        "sendBody": true,
        "bodyContentType": "raw",
        "body": "={{ $json.vevent }}"
      },
      "id": "nextcloud-calendar-api",
      "name": "Nextcloud Calendar API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3000, 450]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations",
        "options": {
          "timeout": 5000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json",
          "Prefer": "return=minimal"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"role\": \"user\",\n  \"message\": \"{{ $json.originalMessage }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"message_hash\": \"{{ $json.messageHash || '' }}\",\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "id": "save-user-message",
      "name": "Save User Message",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2200, 850]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations",
        "options": {
          "timeout": 5000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json",
          "Prefer": "return=minimal"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"role\": \"assistant\",\n  \"message\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"confidence\": {{ $json.confidence || 0.8 }},\n  \"from_cache\": {{ $json.fromCache || false }},\n  \"created_at\": \"{{ $json.timestamp }}\"\n}"
      },
      "id": "save-ai-response",
      "name": "Save AI Response",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [2400, 850]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/appointments",
        "options": {
          "timeout": 5000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json",
          "Prefer": "return=minimal"
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"session_id\": \"{{ $json.sessionId }}\",\n  \"appointment_type\": \"{{ $json.appointmentType }}\",\n  \"extracted_emails\": {{ JSON.stringify($json.emails) }},\n  \"extracted_names\": {{ JSON.stringify($json.names) }},\n  \"language\": \"{{ $json.language }}\",\n  \"start_datetime\": \"{{ $json.calendarData.start }}\",\n  \"end_datetime\": \"{{ $json.calendarData.end }}\",\n  \"status\": \"pending\",\n  \"created_at\": \"{{ $json.extractedAt }}\"\n}"
      },
      "id": "save-appointment",
      "name": "Save Appointment",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [3200, 450]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"fromCache\": {{ $json.fromCache || false }},\n  \"hasAppointmentIntent\": {{ $json.hasAppointmentIntent || false }},\n  \"appointmentCreated\": {{ $json.appointmentCreated || false }}\n}"
      },
      "id": "final-response",
      "name": "Final Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2600, 850]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"appointmentCreated\": true,\n  \"appointmentDetails\": {\n    \"title\": \"{{ $json.eventTitle }}\",\n    \"startTime\": \"{{ $json.startDateTime }}\",\n    \"endTime\": \"{{ $json.endDateTime }}\"\n  }\n}"
      },
      "id": "appointment-response",
      "name": "Appointment Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [3400, 450]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"error\": \"Message is empty\",\n  \"language\": \"en\",\n  \"timestamp\": \"{{ new Date().toISOString() }}\"\n}"
      },
      "id": "empty-message-response",
      "name": "Empty Message Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [800, 900]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"fromCache\": true\n}"
      },
      "id": "cached-response",
      "name": "Cached Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [800, 650]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"response\": \"{{ $json.response }}\",\n  \"language\": \"{{ $json.language }}\",\n  \"sessionId\": \"{{ $json.sessionId }}\",\n  \"timestamp\": \"{{ $json.timestamp }}\",\n  \"error\": true,\n  \"errorHandled\": true\n}"
      },
      "id": "error-response",
      "name": "Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [2200, 900]
    },
    {
      "parameters": {
        "fromEmail": "={{ $env.SMTP_FROM }}",
        "toEmail": "={{ $env.ADMIN_EMAIL }}",
        "subject": "🚨 Critical AI Chatbot Error",
        "text": "Critical error occurred in AI Chatbot System:\n\nTimestamp: {{ $json.timestamp }}\nSession ID: {{ $json.sessionId }}\nLanguage: {{ $json.language }}\nError Context: {{ JSON.stringify($json.errorContext, null, 2) }}\n\nPlease investigate immediately.",
        "options": {
          "priority": "high"
        }
      },
      "id": "critical-error-notification",
      "name": "Critical Error Notification",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [2400, 900]
    },
    {
      "parameters": {
        "jsCode": "// GDPR-compliant daily maintenance\nconst crypto = require('crypto');\n\n// Cleanup old conversation data (30 days)\nconst thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();\n\n// Cleanup old appointment data (90 days)  \nconst ninetyDaysAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).toISOString();\n\n// Clear in-memory cache\nif (typeof global !== 'undefined' && global.chatbotCache) {\n  global.chatbotCache.clear();\n  global.cacheTimestamps.clear();\n}\n\nconst maintenanceTasks = {\n  conversationCleanup: {\n    table: 'conversations',\n    cutoffDate: thirtyDaysAgo,\n    description: 'Delete conversations older than 30 days'\n  },\n  appointmentCleanup: {\n    table: 'appointments', \n    cutoffDate: ninetyDaysAgo,\n    description: 'Delete appointments older than 90 days'\n  },\n  cacheCleanup: {\n    description: 'Clear in-memory cache',\n    completed: true\n  }\n};\n\nreturn [{\n  json: {\n    maintenanceTasks,\n    timestamp: new Date().toISOString(),\n    status: 'ready'\n  }\n}];"
      },
      "id": "maintenance-preparation",
      "name": "Maintenance Preparation",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations?created_at=lt.{{ $json.maintenanceTasks.conversationCleanup.cutoffDate }}",
        "options": {
          "timeout": 30000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "DELETE"
      },
      "id": "cleanup-conversations",
      "name": "Cleanup Old Conversations",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [600, 300]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/appointments?created_at=lt.{{ $json.maintenanceTasks.appointmentCleanup.cutoffDate }}",
        "options": {
          "timeout": 30000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        },
        "httpMethod": "DELETE"
      },
      "id": "cleanup-appointments",
      "name": "Cleanup Old Appointments",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [800, 300]
    },
    {
      "parameters": {
        "jsCode": "// Backup summary and reporting\nconst conversationCleanup = $input.item(0).json;\nconst appointmentCleanup = $input.item(1).json;\n\nconst report = {\n  timestamp: new Date().toISOString(),\n  timezone: 'Europe/Lisbon',\n  tasks: {\n    conversationCleanup: {\n      status: conversationCleanup.error ? 'failed' : 'completed',\n      recordsAffected: conversationCleanup.count || 0,\n      error: conversationCleanup.error || null\n    },\n    appointmentCleanup: {\n      status: appointmentCleanup.error ? 'failed' : 'completed', \n      recordsAffected: appointmentCleanup.count || 0,\n      error: appointmentCleanup.error || null\n    },\n    cacheCleanup: {\n      status: 'completed',\n      description: 'In-memory cache cleared'\n    }\n  },\n  summary: {\n    totalTasksCompleted: [\n      conversationCleanup.error ? 0 : 1,\n      appointmentCleanup.error ? 0 : 1,\n      1 // cache always succeeds\n    ].reduce((a, b) => a + b, 0),\n    totalTasksFailed: [\n      conversationCleanup.error ? 1 : 0,\n      appointmentCleanup.error ? 1 : 0\n    ].reduce((a, b) => a + b, 0)\n  }\n};\n\nreturn [{\n  json: report\n}];"
      },
      "id": "maintenance-report",
      "name": "Maintenance Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1000, 300]
    },
    {
      "parameters": {
        "fromEmail": "={{ $env.SMTP_FROM }}",
        "toEmail": "={{ $env.ADMIN_EMAIL }}",
        "subject": "🔧 Daily Maintenance Report - AI Chatbot",
        "text": "Daily maintenance completed for AI Chatbot System:\n\nTimestamp: {{ $json.timestamp }}\nTimezone: {{ $json.timezone }}\n\n=== TASKS SUMMARY ===\nTasks Completed: {{ $json.summary.totalTasksCompleted }}/3\nTasks Failed: {{ $json.summary.totalTasksFailed }}\n\n=== CONVERSATION CLEANUP ===\nStatus: {{ $json.tasks.conversationCleanup.status }}\nRecords Affected: {{ $json.tasks.conversationCleanup.recordsAffected }}\nError: {{ $json.tasks.conversationCleanup.error || 'None' }}\n\n=== APPOINTMENT CLEANUP ===\nStatus: {{ $json.tasks.appointmentCleanup.status }}\nRecords Affected: {{ $json.tasks.appointmentCleanup.recordsAffected }}\nError: {{ $json.tasks.appointmentCleanup.error || 'None' }}\n\n=== CACHE CLEANUP ===\nStatus: {{ $json.tasks.cacheCleanup.status }}\nDescription: {{ $json.tasks.cacheCleanup.description }}\n\nThis is an automated report from the AI Chatbot maintenance system."
      },
      "id": "maintenance-email-report",
      "name": "Maintenance Email Report",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [1200, 300]
    }
  ],
  "connections": {
    "daily-maintenance-trigger": {
      "main": [
        [
          {
            "node": "maintenance-preparation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "master-webhook": {
      "main": [
        [
          {
            "node": "advanced-language-detection",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "advanced-language-detection": {
      "main": [
        [
          {
            "node": "cache-check-router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cache-check-router": {
      "main": [
        [
          {
            "node": "cache-checker",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "empty-message-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cache-checker": {
      "main": [
        [
          {
            "node": "cached-response",
            "type": "main",
            "index": 0
          },
          {
            "node": "knowledge-base-fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "knowledge-base-fetch": {
      "main": [
        [
          {
            "node": "conversation-history-fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "conversation-history-fetch": {
      "main": [
        [
          {
            "node": "llama-ai-processor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "llama-ai-processor": {
      "main": [
        [
          {
            "node": "llama-api-call",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "llama-api-call": {
      "main": [
        [
          {
            "node": "ai-error-checker",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ai-error-checker": {
      "main": [
        [
          {
            "node": "process-ai-response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "error-handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "process-ai-response": {
      "main": [
        [
          {
            "node": "intent-router",
            "type": "main",
            "index": 0
          },
          {
            "node": "save-user-message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "error-handler": {
      "main": [
        [
          {
            "node": "critical-error-notification",
            "type": "main",
            "index": 0
          },
          {
            "node": "error-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "intent-router": {
      "main": [
        [
          {
            "node": "save-ai-response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "appointment-extractor",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "appointment-extractor": {
      "main": [
        [
          {
            "node": "appointment-validator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "appointment-validator": {
      "main": [
        [
          {
            "node": "nextcloud-calendar-creator",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "save-ai-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "nextcloud-calendar-creator": {
      "main": [
        [
          {
            "node": "nextcloud-calendar-api",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "nextcloud-calendar-api": {
      "main": [
        [
          {
            "node": "save-appointment",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "save-appointment": {
      "main": [
        [
          {
            "node": "appointment-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "save-user-message": {
      "main": [
        [
          {
            "node": "save-ai-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "save-ai-response": {
      "main": [
        [
          {
            "node": "final-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "maintenance-preparation": {
      "main": [
        [
          {
            "node": "cleanup-conversations",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cleanup-conversations": {
      "main": [
        [
          {
            "node": "cleanup-appointments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cleanup-appointments": {
      "main": [
        [
          {
            "node": "maintenance-report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "maintenance-report": {
      "main": [
        [
          {
            "node": "maintenance-email-report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "timezone": "Europe/Lisbon",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "enabled": true
    }
  },
  "staticData": {},
  "tags": [
    {
      "id": "chatbot",
      "name": "AI Chatbot"
    },
    {
      "id": "production",
      "name": "Production"
    },
    {
      "id": "gdpr",
      "name": "GDPR Compliant"
    }
  ],
  "versionId": "2.0.0",
  "meta": {
    "instanceId": "aiquimia-chatbot-enhanced"
  }
}    json: {\n      error: 'Empty message',\n      language: 'en',\n      response: 'Please provide a message.',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst sanitizedMessage = sanitizeMessage(userMessage);\nconst detection = detectLanguage(sanitizedMessage);\nconst timestamp = new Date().toISOString();\n\n// Hash sensitive data for GDPR compliance\nconst hashedIP = hashData(clientIP);\nconst hashedUserAgent = hashData(userAgent);\n\nreturn [{\n  json: {\n    originalMessage: userMessage,\n    sanitizedMessage,\n    detectedLanguage: detection.language,\n    confidence: detection.confidence,\n    sessionId,\n    timestamp,\n    hashedIP,\n    hashedUserAgent,\n    messageLength: sanitizedMessage.length\n  }\n}];"
      },
      "id": "advanced-language-detection",
      "name": "Advanced Language Detection",\n      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [400, 800]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.sanitizedMessage }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "cache-check-router",
      "name": "Cache Check Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [600, 800]
    },
    {
      "parameters": {
        "jsCode": "// In-Memory Cache Implementation (Redis alternative for development)\nclass SimpleCache {\n  constructor() {\n    if (!global.chatbotCache) {\n      global.chatbotCache = new Map();\n      global.cacheTimestamps = new Map();\n    }\n  }\n  \n  get(key) {\n    const now = Date.now();\n    const timestamp = global.cacheTimestamps.get(key);\n    \n    // Check if expired (10 minutes = 600000ms)\n    if (!timestamp || (now - timestamp) > 600000) {\n      this.delete(key);\n      return null;\n    }\n    \n    return global.chatbotCache.get(key);\n  }\n  \n  set(key, value) {\n    // Limit cache size to 1000 entries\n    if (global.chatbotCache.size >= 1000) {\n      const firstKey = global.chatbotCache.keys().next().value;\n      this.delete(firstKey);\n    }\n    \n    global.chatbotCache.set(key, value);\n    global.cacheTimestamps.set(key, Date.now());\n  }\n  \n  delete(key) {\n    global.chatbotCache.delete(key);\n    global.cacheTimestamps.delete(key);\n  }\n  \n  clear() {\n    global.chatbotCache.clear();\n    global.cacheTimestamps.clear();\n  }\n}\n\nconst cache = new SimpleCache();\nconst { sanitizedMessage, sessionId, detectedLanguage } = $input.first().json;\n\n// Create cache key\nconst cacheKey = `${sessionId}:${sanitizedMessage.toLowerCase().replace(/\\s+/g, '')}`;\n\n// Check cache\nconst cachedResponse = cache.get(cacheKey);\n\nif (cachedResponse) {\n  return [{\n    json: {\n      ...cachedResponse,\n      fromCache: true,\n      cacheKey,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\n// Pass through if not cached\nreturn [{\n  json: {\n    ...$input.first().json,\n    cacheKey,\n    fromCache: false\n  }\n}];"
      },
      "id": "cache-checker",
      "name": "Cache Checker",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [800, 750]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/company_knowledge?active=eq.true&order=priority.asc&limit=50",
        "options": {
          "timeout": 10000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        }
      },
      "id": "knowledge-base-fetch",
      "name": "Knowledge Base Fetch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1000, 750]
    },
    {
      "parameters": {
        "url": "={{ $env.SUPABASE_URL }}/rest/v1/conversations?session_id=eq.{{ $json.sessionId }}&order=created_at.desc&limit=5",
        "options": {
          "timeout": 5000
        },
        "headers": {
          "Authorization": "Bearer {{ $env.SUPABASE_SERVICE_KEY }}",
          "apikey": "{{ $env.SUPABASE_SERVICE_KEY }}",
          "Content-Type": "application/json"
        }
      },
      "id": "conversation-history-fetch",
      "name": "Conversation History Fetch",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1200, 750]
    },
    {
      "parameters": {
        "jsCode": "// Llama3.2 AI Processor with Bilingual System Prompts\nconst { \n  sanitizedMessage, \n  detectedLanguage, \n  sessionId, \n  cacheKey \n} = $input.first().json;\n\nconst knowledgeBase = $input.item(1).json || [];\nconst conversationHistory = $input.item(2).json || [];\n\n// Build context from knowledge base\nconst buildKnowledgeContext = (kb, lang) => {\n  if (!Array.isArray(kb) || kb.length === 0) return '';\n  \n  const relevantKB = kb.filter(item => \n    item.language === lang || item.language === 'both'\n  ).slice(0, 10);\n  \n  return relevantKB.map(item => \n    `${item.title || 'Info'}: ${item.content || item.description || ''}`\n  ).join('\\n');\n};\n\n// Build conversation context\nconst buildConversationContext = (history) => {\n  if (!Array.isArray(history) || history.length === 0) return '';\n  \n  return history.slice(0, 3).reverse().map(msg => \n    `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.message}`\n  ).join('\\n');\n};\n\n// System prompts\nconst systemPrompts = {\n  pt: `Você é um assistente de IA bilíngue profissional e amigável para uma startup de IA. \nResponda em português (PT-PT) de forma concisa (máximo 150 palavras), profissional mas acessível.\n\nDiretrizes:\n- Seja útil, preciso e honesto\n- Se não souber algo, admita e ofereça alternativas\n- Para agendamentos, extraia: nome, email, data, hora, tipo de serviço\n- Use informações da empresa quando relevante\n- Mantenha o tom profissional mas caloroso\n\nContexto da empresa:\n{{ KNOWLEDGE_CONTEXT }}\n\nHistórico da conversa:\n{{ CONVERSATION_CONTEXT }}\n\nResponda à seguinte mensagem do utilizador:`,\n  \n  en: `You are a professional and friendly bilingual AI assistant for an AI startup.\nRespond in English concisely (max 150 words), professional yet approachable.\n\nGuidelines:\n- Be helpful, accurate, and honest\n- If unsure, admit it and offer alternatives\n- For appointments, extract: name, email, date, time, service type\n- Use company information when relevant\n- Maintain professional but warm tone\n\nCompany context:\n{{ KNOWLEDGE_CONTEXT }}\n\nConversation history:\n{{ CONVERSATION_CONTEXT }}\n\nRespond to the following user message:`\n};\n\n// Build final prompt\nconst knowledgeContext = buildKnowledgeContext(knowledgeBase, detectedLanguage);\nconst conversationContext = buildConversationContext(conversationHistory);\n\nconst systemPrompt = systemPrompts[detectedLanguage]\n  .replace('{{ KNOWLEDGE_CONTEXT }}', knowledgeContext || 'No specific company information available.')\n  .replace('{{ CONVERSATION_CONTEXT }}', conversationContext || 'No previous conversation.');\n\nconst fullPrompt = `${systemPrompt}\\n\\nUser: ${sanitizedMessage}`;\n\n// Prepare API request body\nconst requestBody = {\n  model: process.env.LLAMA_MODEL || 'llama3.2:latest',\n  prompt: fullPrompt,\n  stream: false,\n  options: {\n    temperature: 0.7,\n    max_tokens: 500,\n    top_p: 0.9,\n    stop: ['User:', 'Assistant:']\n  }\n};\n\nreturn [{\n  json: {\n    requestBody,\n    systemPrompt,\n    knowledgeContext,\n    conversationContext,\n    detectedLanguage,\n    sessionId,\n    cacheKey,\n    originalMessage: sanitizedMessage,\n    timestamp: new Date().toISOString()\n  }\n}];"
      },
      "id": "llama-ai-processor",
      "name": "Llama3.2 AI Processor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1400, 750]
    },
    {
      "parameters": {
        "url": "={{ $env.LLAMA_URL || 'http://localhost:11434' }}/api/generate",
        "options": {
          "timeout": 30000,
          "retry": {
            "enabled": true,
            "maxTries": 3\n          }\n        },\n        "sendBody": true,\n        "bodyContentType": "json",\n        "jsonBody": "={{ $json.requestBody }}"\n      },\n      "id": "llama-api-call",\n      "name": "Llama API Call",\n      "type": "n8n-nodes-base.httpRequest",\n      "typeVersion": 4,\n      "position": [1600, 750]\n    },\n    {\n      "parameters": {\n        "conditions": {\n          "options": {\n            "caseSensitive": true,\n            "leftValue": "",\n            "typeValidation": "strict"\n          },\n          "conditions": [\n            {\n              "leftValue": "={{ $json.error }}",\n              "rightValue": "",\n              "operator": {\n                "type": "string",\n                "operation": "exists"\n              }\n            }\n          ],\n          "combineOperation": "any"\n        }\n      },\n      "id": "ai-error-checker",\n      "name": "AI Error Checker",\n      "type": "n8n-nodes-base.if",\n      "typeVersion": 2,\n      "position": [1800, 750]\n    },\n    {\n      "parameters": {\n        "jsCode": "// Process successful AI response and cache it\nconst response = $input.first().json;\n\n// Extract AI response from Llama output\nconst aiResponse = response.response || response.text || '';\nconst { detectedLanguage, sessionId, cacheKey, originalMessage } = response;\n\n// Clean up AI response\nconst cleanResponse = aiResponse\n  .replace(/^(Assistant:|AI:)\\s*/i, '')\n  .replace(/\\n\\s*User:/i, '')\n  .trim();\n\n// Cache the response\nif (typeof global !== 'undefined' && global.chatbotCache && cacheKey) {\n  const cacheData = {\n    response: cleanResponse,\n    language: detectedLanguage,\n    sessionId,\n    originalMessage,\n    cachedAt: new Date().toISOString()\n  };\n  \n  global.chatbotCache.set(cacheKey, cacheData);\n  global.cacheTimestamps.set(cacheKey, Date.now());\n}\n\n// Detect intent for appointment scheduling\nconst appointmentKeywords = {\n  pt: /\\b(agendar|marcar|reunião|encontro|consulta|appointment|schedule|meeting)\\b/i,\n  en: /\\b(schedule|book|appointment|meeting|consultation|agendar|marcar)\\b/i\n};\n\nconst hasAppointmentIntent = \n  appointmentKeywords.pt.test(originalMessage) ||\n  appointmentKeywords.en.test(originalMessage) ||\n  appointmentKeywords.pt.test(cleanResponse) ||\n  appointmentKeywords.en.test(cleanResponse);\n\nreturn [{\n  json: {\n    response: cleanResponse,\n    language: detectedLanguage,\n    sessionId,\n    originalMessage,\n    hasAppointmentIntent,\n    fromCache: false,\n    timestamp: new Date().toISOString(),\n    confidence: response.confidence || 0.8\n  }\n}];"
      },
      "id": "process-ai-response",
      "name": "Process AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 650]
    },
    {
      "parameters": {
        "jsCode": "// GDPR-compliant error handler with fallback responses\nconst { detectedLanguage, sessionId, originalMessage } = $input.first().json;\nconst error = $input.first().json.error || 'Unknown error';\n\n// Fallback responses in both languages\nconst fallbackResponses = {\n  pt: [\n    'Peço desculpa, mas estou com dificuldades técnicas neste momento. Pode tentar novamente em alguns minutos?',\n    'Lamento, mas não consegui processar o seu pedido. Por favor, tente reformular a sua mensagem.',\n    'Estou temporariamente indisponível. Por favor, contacte-nos diretamente se for urgente.'\n  ],\n  en: [\n    'I apologize, but I am experiencing technical difficulties at the moment. Could you try again in a few minutes?',\n    'Sorry, I could not process your request. Please try rephrasing your message.',\n    'I am temporarily unavailable. Please contact us directly if this is urgent.'\n  ]\n};\n\n// Select appropriate fallback\nconst responses = fallbackResponses[detectedLanguage] || fallbackResponses['en'];\nconst fallbackResponse = responses[Math.floor(Math.random() * responses.length)];\n\n// Log error for monitoring (without sensitive data)\nconst errorContext = {\n  timestamp: new Date().toISOString(),\n  sessionId,\n  language: detectedLanguage,\n  messageLength: originalMessage?.length || 0,\n  errorType: typeof error === 'object' ? error.name || 'Unknown' : 'String error'\n};\n\nconsole.error('AI Chatbot Error:', errorContext);\n\nreturn [{\n  json: {\n    response: fallbackResponse,\n    language: detectedLanguage,\n    sessionId,\n    isError: true,\n    errorHandled: true,\n    timestamp: new Date().toISOString(),\n    errorContext\n  }\n}];"
      },
      "id": "error-handler",
      "name": "GDPR Error Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 900]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.hasAppointmentIntent }}",
              "operation": "equal",
              "value2": true
            }
          ]
        }
      },
      "id": "intent-router",
      "name": "Intent Router",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2200, 650]
    },
    {
      "parameters": {
        "jsCode": "// Extract appointment details from message\nconst { originalMessage, language, sessionId, response } = $input.first().json;\nconst text = `${originalMessage} ${response}`.toLowerCase();\n\n// Regex patterns for extracting appointment information\nconst patterns = {\n  email: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}/g,\n  phone: /(?:\\+351|00351|351)?\\s*[0-9]{2,3}\\s*[0-9]{3}\\s*[0-9]{3,4}|[0-9]{9}/g,\n  date: {\n    pt: /(?:dia|em)\\s+(\\d{1,2})\\s*(?:de|\\/)\\s*(\\d{1,2}|janeiro|fevereiro|março|abril|maio|junho|julho|agosto|setembro|outubro|novembro|dezembro)\\s*(?:de|\\/)\\s*(\\d{4}|\\d{2})/gi,\n    en: /(?:on|for)\\s+(\\d{1,2})(?:st|nd|rd|th)?\\s+(january|february|march|april|may|june|july|august|september|october|november|december|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\\s+(\\d{4}|\\d{2})/gi\n  },\n  time: /(?:às|at|around)\\s*(\\d{1,2})(?:[:h]\\s*(\\d{2}))?\\s*(?:am|pm|h|horas)?/gi,\n  name: /(?:nome|name|i'm|sou)\\s+(?:é\\s+)?([a-zA-ZÀ-ÿ\\s]{2,30})/gi\n};\n\n// Extract information\nconst extractedData = {\n  sessionId,\n  language,\n  extractedAt: new Date().toISOString(),\n  emails: (text.match(patterns.email) || []).slice(0, 3),\n  phones: (text.match(patterns.phone) || []).slice(0, 2),\n  names: [],\n  dates: [],\n  times: [],\n  appointmentType: 'consultation' // default\n};\n\n// Extract names\nlet nameMatch;\nwhile ((nameMatch = patterns.name.exec(text)) !== null) {\n  const name = nameMatch[1].trim();\n  if (name.length > 2 && name.length < 30) {\n    extractedData.names.push(name);\n  }\n}\n\n// Extract dates\nconst datePattern = patterns.date[language] || patterns.date['en'];\nlet dateMatch;\nwhile ((dateMatch = datePattern.exec(text)) !== null) {\n  extractedData.dates.push({\n    day: dateMatch[1],\n    month: dateMatch[2],\n    year: dateMatch[3]\n  });\n}\n\n// Extract times\nlet timeMatch;\nwhile ((timeMatch = patterns.time.exec(text)) !== null) {\n  extractedData.times.push({\n    hour: timeMatch[1],\n    minute: timeMatch[2] || '00'\n  });\n}\n\n// Determine appointment type\nconst serviceKeywords = {\n  consultation: /consulta|consultation|meeting|reunião/i,\n  demo: /demo|demonstração|presentation|apresentação/i,\n  support: /support|suporte|help|ajuda/i\n};\n\nfor (const [type, pattern] of Object.entries(serviceKeywords)) {\n  if (pattern.test(text)) {\n    extractedData.appointmentType = type;\n    break;\n  }\n}\n\n// Validate if we have minimum required information\nconst hasMinimumInfo = \n  extractedData.emails.length > 0 || \n  extractedData.phones.length > 0 || \n  extractedData.names.length > 0;\n\nreturn [{\n  json: {\n    ...extractedData,\n    hasMinimumInfo,\n    originalMessage,\n    needsMoreInfo: !hasMinimumInfo\n  }\n}];"
      },
      "id": "appointment-extractor",
      "name": "Appointment Details Extractor",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 550]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.hasMinimumInfo }}",
              "operation": "equal",
              "value2": true
            }
          ]
        }
      },
      "id": "appointment-validator",
      "name": "Appointment Validator",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2600, 550]
    },
    {
      "parameters": {
        "jsCode": "// Create Nextcloud calendar event\nconst appointmentData = $input.first().json;\nconst { emails, names, dates, times, language, appointmentType } = appointmentData;\n\n// Prepare event data\nconst eventTitle = language === 'pt' \n  ? `Consulta - ${names[0] || 'Cliente'}` \n  : `Consultation - ${names[0] || 'Client'}`;\n\nconst eventDescription = language === 'pt'\n  ? `Tipo: ${appointmentType}\\nIdioma: Português\\nEmail: ${emails[0] || 'N/A'}\\nExtraído automaticamente do chat`\n  : `Type: ${appointmentType}\\nLanguage: English\\nEmail: ${emails[0] || 'N/A'}\\nAutomatically extracted from chat`;\n\n// Default to next business day if no date specified\nconst eventDate = dates.length > 0 \n  ? new Date(`${dates[0].year}-${dates[0].month.toString().padStart(2, '0')}-${dates[0].day.toString().padStart(2, '0')}`)\n  : new Date(Date.now() + 24 * 60 * 60 * 1000); // tomorrow\n\nconst eventTime = times.length > 0 \n  ? `${times[0].hour.padStart(2, '0')}:${times[0].minute.padStart(2, '0')}`\n  : '14:00'; // default 2 PM\n\n// Create iCal VEVENT format\nconst startDateTime = new Date(`${eventDate.toISOString().split('T')[0]}T${eventTime}:00.000Z`);\nconst endDateTime = new Date(startDateTime.getTime() + 60 * 60 * 1000); // 1 hour duration\n\nconst vevent = [\n  'BEGIN:VCALENDAR',\n  'VERSION:2.0',\n  'PRODID:-//AI Chatbot//Appointment Scheduler//EN',\n  'CALSCALE:GREGORIAN',\n  'METHOD:REQUEST',\n  'BEGIN:VEVENT',\n  `UID:${Date.now()}-${Math.random().toString(36).substr(2, 9)}@aiquimia.com`,\n  `DTSTART:${startDateTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`,\n  `DTEND:${endDateTime.toISOString().replace(/[-:]/g, '').split('.')[0]}Z`,\n  `SUMMARY:${eventTitle}`,\n  `DESCRIPTION:${eventDescription}`,\n  `ORGANIZER:mailto:admin@aiquimia.com`,\n  emails.length > 0 ? `ATTENDEE:mailto:${emails[0]}` : '',\n  'STATUS:TENTATIVE',\n  'SEQUENCE:0',\n  'BEGIN:VALARM',\n  'TRIGGER:-PT15M',\n  'ACTION:DISPLAY',\n  'DESCRIPTION:Appointment Reminder',\n  'END:VALARM',\n  'END:VEVENT',\n  'END:VCALENDAR'\n].filter(line => line).join('\\r\\n');\n\nreturn [{\n